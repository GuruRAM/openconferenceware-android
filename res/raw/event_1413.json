{"description": "\n<p>Multi-threaded servers compete for the global interpreter lock (GIL) and incur the cost of continuous context switching, potential deadlocks, or plain wasted cycles. Asynchronous servers, on the other hand, create a mess of callbacks and errbacks, complicating the code. But, what if, you could get all the benefits of asynchronous programming, while preserving the synchronous look and feel of the code \u2013 no threads, no callbacks?</p>\n<p>In this talk we\u2019ll look at how Ruby 1.9 Fibers, combined with EventMachine, can enable us to build a fully asynchronous web-server, while preserving the feeling of synchronous code \u2013 the best of both worlds.  A cooperative, pure IO-scheduled web server to power your next Rails, or Rack application!</p>\n<p>In this talk we will dive deep into the architecture, libraries, and internals of Ruby:</p>\n\n&nbsp;&nbsp;&nbsp;&#8226; Limitations of threaded web servers, libraries and the global interpreter lock<br/>\n&nbsp;&nbsp;&nbsp;&#8226; (Dis)advantages of asynchronous network programming with the EventMachine library<br/>\n&nbsp;&nbsp;&nbsp;&#8226; Changes to Ruby 1.9 threading, <span class=\"caps\">GIL</span>, and introduction of Fibers<br/>\n&nbsp;&nbsp;&nbsp;&#8226; Cooperative IO scheduling in Ruby 1.9: Pro\u2019s &#38; Cons<br/>\n&nbsp;&nbsp;&nbsp;&#8226; Fibers + Callbacks: next generation Ruby web-server<br/>\n<br/>\n", "title": "No Callbacks, No Threads: Async & Cooperative Web Servers with Ruby 1.9", "start_time": "2010-07-22T13:40:00-07:00", "track_id": 16, "user_ids": [1443], "room_id": 6, "end_time": "2010-07-22T14:20:00-07:00", "id": 1413}